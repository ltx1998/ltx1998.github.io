<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java技术汇总</title>
    <link href="/2022/07/02/java%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/"/>
    <url>/2022/07/02/java%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文分为十九个模块，分别是： Java 基础、容器、多线程、反射、对象拷贝、Java Web 、异常、网络、设计模式、Spring&#x2F;Spring MVC、Spring Boot&#x2F;Spring Cloud、Hibernate、MyBatis、RabbitMQ、Kafka、Zookeeper、MySQL、Redis、JVM</p><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><ol><li>JDK 和 JRE 有什么区别？</li></ol><p>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</p><p>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。具体来说 JDK 其 实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p><ol start="2"><li>&#x3D;&#x3D; 和 equals 的区别是什么？</li></ol><p>&#x3D;&#x3D; 解读</p><p>对于基本类型和引用类型 &#x3D;&#x3D; 的作用效果是不同的，如下所示：</p><p>基本类型：比较的是值是否相同；</p><p>引用类型：比较的是引用是否相同；</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> “string”;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> “string”;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(“string”);<br><br>System.out.println(xy); <span class="hljs-comment">// true</span><br><br>System.out.println(xz); <span class="hljs-comment">// false</span><br><br>System.out.println(x.equals(y)); <span class="hljs-comment">// true</span><br><br>System.out.println(x.equals(z)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 &#x3D;&#x3D; 也是 true，而 new String()方法则重写开辟了内存空间，所以 &#x3D;&#x3D; 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><p>equals 解读</p><p>equals 本质上就是 &#x3D;&#x3D;，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p><p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span> &#123;<br><br><span class="hljs-built_in">this</span>.name = name;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><br> <span class="hljs-keyword">return</span> name;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><br> <span class="hljs-built_in">this</span>.name = name;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-type">Cat</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(“王磊”);<br><br><span class="hljs-type">Cat</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(“王磊”);<br><br>System.out.println(c1.equals(c2)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>原来 equals 本质上就是 &#x3D;&#x3D;。</p><p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(“老王”);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(“老王”);<br><br>System.out.println(s1.equals(s2)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> &#123;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) &#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">anotherString</span> <span class="hljs-operator">=</span> (String)anObject;<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> value.length;<br><br><span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br><br><span class="hljs-type">char</span> v1[] = value;<br><br><span class="hljs-type">char</span> v2[] = anotherString.value;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br><br><span class="hljs-keyword">if</span> (v1[i] != v2[i])<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>i++;<br><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p><p>总结 ：&#x3D;&#x3D; 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><ol start="3"><li>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</li></ol><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> “通话”;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> “重地”;<br><br>System. out. println(String. format(“str1：%d | str2：%d”, str1. hashCode(),str2. <br><br>hashCode()));<br><br>System. out. println(str1. equals(str2));<br><br><span class="hljs-comment">//执行的结果：</span><br><br>str1：<span class="hljs-number">1179395</span> | str2：<span class="hljs-number">1179395</span><br><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><ol start="4"><li>final 在 Java 中有什么作用？</li></ol><p>final 修饰的类叫最终类，该类不能被继承。</p><p>final 修饰的方法不能被重写。</p><p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p><ol start="5"><li>Java 中的 Math. round(-1. 5) 等于多少？</li></ol><p>等于 -1，Math. round 四舍五入大于 0. 5 向上取整的。</p><ol start="6"><li>String 属于基础的数据类型吗？</li></ol><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于引用类型。</p><ol start="7"><li>Java 中操作字符串都有哪些类？它们之间有什么区别？</li></ol><p>String、StringBuffer和StringBuilder</p><p>String是final修饰的，不可变的，每次操作都会产生新的String对象</p><p>StringBuffer和StringBuilder都是在原对象上操作</p><p>StringBuffer是线程安全的，StringBuilder是线程不安全的</p><p>性能：StringBuilder&gt;StringBuffer&gt;String</p><p>使用场景：优先吃用StringBuilder，多线程使用StringBuffer</p><ol start="8"><li>String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</li></ol><p>不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，Java 虚拟机会将其分配到常量池中；而String str&#x3D;new String(“i”) 则会被分到堆内存中。</p><ol start="9"><li>如何将字符串反转？</li></ol><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringBuffer reverse</span><br><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><br>stringBuffer. append(“abcdefg”);<br><br>System. out. println(stringBuffer. reverse()); <span class="hljs-comment">// gfedcba</span><br><br><span class="hljs-comment">// StringBuilder reverse</span><br><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>stringBuilder. append(“abcdefg”);System. out. println(stringBuilder. reverse()); <span class="hljs-comment">// gfedcba</span><br></code></pre></td></tr></table></figure><ol start="10"><li>String 类的常用方法都有那些？</li></ol><p>indexOf()：返回指定字符的索引。</p><p>charAt()：返回指定索处的字符。</p><p>replace()：字符串替换。</p><p>trim()：去除字符串两端空白。</p><p>split()：分割字符串，返回一个分割后的字符串数组。</p><p>getBytes()：返回字符串的 byte 类型数组。</p><p>length()：返回字符串长度。</p><p>toLowerCase()：将字符串转成小写字母。</p><p>toUpperCase()：将字符串转成大写字符。</p><p>substring()：截取字符串。</p><p>equals()：字符串比较。</p><ol start="11"><li>抽象类必须要有抽象方法吗？</li></ol><p>不需要，抽象类不一定非要有抽象方法。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span> &#123;<br><br>System. out. println(“hi~”);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p><ol start="12"><li>普通类和抽象类有哪些区别？</li></ol><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。</p><p>抽象类不能直接实例化，普通类可以直接实例化。</p><ol start="13"><li>抽象类能使用 final 修饰吗？</li></ol><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p><ol start="14"><li>接口和抽象类有什么区别？</li></ol><p>默认方法实现：抽象类可以有默认的方法实现；接口不能有默认的方法实现。</p><p>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</p><p>构造函数：抽象类可以有构造函数；接口不能有。</p><p>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</p><p>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p><ol start="15"><li>Java 中 IO 流分为几种？</li></ol><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流和字符流。</p><p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><ol start="16"><li>BIO、NIO、AIO 有什么区别？</li></ol><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</p><p>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端Channel（通道）通讯，实现了多路复用。</p><p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p><ol start="17"><li>Files 的常用方法都有哪些？</li></ol><p>Files. exists()：检测文件路径是否存在。</p><p>Files. createFile()：创建文件。</p><p>Files. createDirectory()：创建文件夹。</p><p>Files. delete()：删除一个文件或目录。</p><p>Files. copy()：复制文件。</p><p>Files. move()：移动文件。</p><p>Files. size()：查看文件个数。</p><p>Files. read()：读取文件。</p><p>Files. write()：写入文件。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ol start="18"><li>Java 容器都有哪些？</li></ol><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p><p>Collection</p><p>List</p><p>ArrayList</p><p>LinkedList</p><p>Vector</p><p>Stack</p><p>Set</p><p>HashSet</p><p>LinkedHashSet</p><p>TreeSet</p><p>MapHashMap</p><p>LinkedHashMap</p><p>TreeMap</p><p>ConcurrentHashMap</p><p>Hashtable</p><ol start="19"><li>Collection 和 Collections 有什么区别？</li></ol><p>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</p><p>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</p><ol start="20"><li>List、Set、Map 之间的区别是什么？</li></ol><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p><ol start="21"><li>HashMap 和 Hashtable 有什么区别？</li></ol><p>存储：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。</p><p>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</p><p>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p><ol start="22"><li>如何决定使用 HashMap 还是 TreeMap？</li></ol><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p><ol start="23"><li>说一下 HashMap 的实现原理？</li></ol><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p><ol start="24"><li>说一下 HashSet 的实现原理？</li></ol><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><ol start="25"><li>ArrayList 和 LinkedList 的区别是什么？</li></ol><p>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</p><p>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p><p>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><ol start="26"><li>如何实现数组和 List 之间的转换？</li></ol><p>数组转 List：使用 Arrays. asList(array) 进行转换。</p><p>List 转数组：使用 List 自带的 toArray() 方法。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// list to array</span><br><br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>list. add(“王磊”);<br><br>list. add(“的博客”);<br><br>list. toArray();<br><br><span class="hljs-comment">// array to list</span><br><br>String[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;“王磊”,“的博客”&#125;;<br><br>Arrays. asList(array);<br></code></pre></td></tr></table></figure><ol start="27"><li>ArrayList 和 Vector 的区别是什么？</li></ol><p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</p><p>性能：ArrayList 在性能方面要优于 Vector。</p><p>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p><ol start="28"><li>Array 和 ArrayList 有何区别？</li></ol><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</p><p>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</p><p>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p><ol start="29"><li>在 Queue 中 poll()和 remove()有什么区别？</li></ol><p>相同点：都是返回第一个元素，并在队列中删除返回的对象。</p><p>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代码示例：</span><br><span class="hljs-type">Queue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br><br>queue. offer(“string”); <span class="hljs-comment">// add</span><br><br>System. out. println(queue. poll());<br><br>System. out. println(queue. remove());<br><br>System. out. println(queue. size());<br></code></pre></td></tr></table></figure><ol start="30"><li>哪些集合类是线程安全的？</li></ol><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应</p><p>的线程安全类就是 ConcurrentHashMap。</p><ol start="31"><li>迭代器 Iterator 是什么？</li></ol><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><ol start="32"><li>Iterator 怎么使用？有什么特点？</li></ol><p>Iterator 使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list. iterator();<br><br><span class="hljs-keyword">while</span>(it. hasNext())&#123;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> it. next();<br><br>System. out. println(obj);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出ConcurrentModificationException 异常。</p><ol start="33"><li>Iterator 和 ListIterator 有什么区别？</li></ol><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</p><p>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。</p><p>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元</p><p>素、获取前面或后面元素的索引位置。</p><ol start="34"><li>怎么确保一个集合不能被修改？</li></ol><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出Java.lang.UnsupportedOperationException 异常。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>list. add(“x”);<span class="hljs-type">Collection</span> <span class="hljs-variable">clist</span> <span class="hljs-operator">=</span> Collections. unmodifiableCollection(list);<br><br>clist. add(“y”); <span class="hljs-comment">// 运行时此行报错</span><br><br>System. out. println(list. size());<br></code></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ol start="35"><li>并行和并发有什么区别？</li></ol><p>并行：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</p><p>并发：多个处理器或多核处理器同时处理多个任务。</p><p>如下图：</p><p>并发和并行</p><p>并发 &#x3D; 两个队列和一台咖啡机。</p><p>并行 &#x3D; 两个队列和两台咖啡机。</p><ol start="36"><li>线程和进程的区别？</li></ol><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><ol start="37"><li>守护线程是什么？</li></ol><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><ol start="38"><li>创建线程有哪几种方式？</li></ol><p>创建线程有三种方式：</p><p>继承 Thread 重新 run 方法；</p><p>实现 Runnable 接口；</p><p>实现 Callable 接口。</p><ol start="39"><li>说一下 runnable 和 callable 有什么区别？</li></ol><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p><ol start="40"><li>线程有哪些状态？</li></ol><p>线程的状态：</p><p>NEW 尚未启动</p><p>RUNNABLE 正在执行中</p><p>BLOCKED 阻塞的（被同步锁或者 IO 锁阻塞）</p><p>WAITING 永久等待状态TIMED_WAITING 等待指定的时间重新被唤醒的状态</p><p>TERMINATED 执行完成</p><ol start="41"><li>sleep() 和 wait() 有什么区别？</li></ol><p>类的不同：sleep() 来自 Thread，wait() 来自 Object。</p><p>释放锁：sleep() 不释放锁；wait() 释放锁。</p><p>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()&#x2F;notifyAll()直接唤醒。</p><ol start="42"><li>notify()和 notifyAll()有什么区别？</li></ol><p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等</p><p>待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><ol start="43"><li>线程的 run() 和 start() 有什么区别？</li></ol><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><ol start="44"><li>创建线程池有哪几种方式？</li></ol><p>线程池创建有七种方式，最核心的是最后一种：</p><p>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads；newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；newScheduledThreadPool(int corePoolSize)：和 newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建 ForkJoinPool，利用 Work-Stealing 算法，并行地处理任务，不保证处理顺序；ThreadPoolExecutor()：是最原始的线程池创建，上面 1-3 创建方式都是对 ThreadPoolExecutor 的封装。</p><ol start="45"><li>线程池都有哪些状态？</li></ol><p>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</p><p>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</p><p>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</p><p>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子</p><p>方法 terminated()。</p><p>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</p><ol start="46"><li>线程池中 submit() 和 execute() 方法有什么区别？</li></ol><p>execute()：只能执行 Runnable 类型的任务。</p><p>submit()：可以执行 Runnable 和 Callable 类型的任务。</p><p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p><ol start="47"><li>在 Java 程序中怎么保证多线程的运行安全？</li></ol><p>方法一：使用安全类，比如 Java. util. concurrent 下的类。</p><p>方法二：使用自动锁 synchronized。</p><p>方法三：使用手动锁 Lock。</p><p>手动锁 Java 示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>lock. lock();<br><br><span class="hljs-keyword">try</span> &#123;<br><br>System. out. println(“获得锁”);<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><br>System. out. println(“释放锁”);<br><br>lock. unlock();<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="48"><li>多线程中 synchronized 锁升级的原理是什么？</li></ol><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成synchronized 锁的升级。锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><ol start="49"><li>什么是死锁？</li></ol><p>当线程 A 持有独占锁 a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><ol start="50"><li>怎么防止死锁？</li></ol><p>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，</p><p>设置超时时间，超时可以退出防止死锁。</p><p>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</p><p>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</p><p>尽量减少同步的代码块。</p><ol start="51"><li>ThreadLocal 是什么？有哪些使用场景？</li></ol><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副</p><p>本，而不会影响其它线程所对应的副本。</p><p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><ol start="52"><li>说一下 synchronized 底层实现原理？</li></ol><p>synchronized 是由一对 monitorenter&#x2F;monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对</p><p>此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁</p><p>（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p><ol start="53"><li>synchronized 和 volatile 的区别是什么？</li></ol><p>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</p><p>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见</p><p>性和原子性。</p><p>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p><ol start="54"><li>synchronized 和 Lock 有什么区别？</li></ol><p>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</p><p>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock </p><p>需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</p><p>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p><ol start="55"><li>synchronized 和 ReentrantLock 区别是什么？</li></ol><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p><p>主要区别如下：</p><p>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</p><p>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</p><p>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</p><p>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</p><ol start="56"><li>说一下 atomic 的原理？</li></ol><p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免</p><p>synchronized 的高开销，执行效率大为提升。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ol start="57"><li>什么是反射？</li></ol><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><ol start="58"><li>什么是 Java 序列化？什么情况下需要序列化？</li></ol><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。以下情况需要使用 Java 序列化：</p><p>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</p><p>想用套接字在网络上传送对象的时候；</p><p>想通过 RMI（远程方法调用）传输对象的时候。</p><ol start="59"><li>动态代理是什么？有哪些应用？</li></ol><p>动态代理是运行时动态生成代理类。</p><p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端mock、rpc，Java 注解对象获取等。</p><ol start="60"><li>怎么实现动态代理？</li></ol><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><ol start="61"><li>为什么要使用克隆？</li></ol><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p><ol start="62"><li>如何实现对象克隆？</li></ol><p>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</p><p>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p><ol start="63"><li>深拷贝和浅拷贝区别是什么？</li></ol><p>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p><p>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p><h2 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h2><ol start="64"><li>JSP 和 servlet 有什么区别？</li></ol><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p><ol start="65"><li>JSP 有哪些内置对象？作用分别是什么？</li></ol><p>JSP 有 9 大内置对象：</p><p>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；</p><p>response：封装服务器对客户端的响应；</p><p>pageContext：通过该对象可以获取其他对象；</p><p>session：封装用户会话的对象；</p><p>application：封装服务器运行环境的对象；</p><p>out：输出服务器响应的输出流对象；</p><p>config：Web 应用的配置对象；</p><p>page：JSP 页面本身（相当于 Java 程序中的 this）；</p><p>exception：封装页面抛出异常的对象。</p><ol start="66"><li>说一下 JSP 的 4 种作用域？</li></ol><p>page：代表与一个页面相关的对象和属性。</p><p>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</p><p>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</p><p>application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</p><ol start="67"><li>session 和 cookie 有什么区别？</li></ol><p>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</p><p>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</p><p>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</p><p>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</p><ol start="68"><li>说一下 session 的工作原理？</li></ol><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p><ol start="69"><li>如果客户端禁止 cookie 能实现 session 还能用吗？</li></ol><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加sessionid 的方式保证 session 能正常使用。</p><ol start="70"><li>spring mvc 和 struts 的区别是什么？</li></ol><p>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。</p><p>数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。</p><p>拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致</p><p>struts2 的配置文件量比 spring mvc 大。</p><p>对 ajax 的支持：spring mvc 集成了 ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</p><ol start="71"><li>如何避免 SQL 注入？</li></ol><p>使用预处理 PreparedStatement。</p><p>使用正则表达式过滤掉字符中的特殊字符。</p><ol start="72"><li>什么是 XSS 攻击，如何避免？</li></ol><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p><p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p><ol start="73"><li>什么是 CSRF 攻击，如何避免？</li></ol><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p><p>防御手段：</p><p>验证请求来源地址；</p><p>关键操作添加验证码；</p><p>在请求地址添加 token 并验证。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol start="74"><li>throw 和 throws 的区别？</li></ol><p>throw：是真实抛出一个异常。</p><p>throws：是声明可能会抛出一个异常。</p><ol start="75"><li>final、finally、finalize 有什么区别？</li></ol><p>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能被改变，只能使用。</p><p>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</p><p>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</p><ol start="76"><li>try-catch-finally 中哪个部分可以省略？</li></ol><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p><ol start="77"><li>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</li></ol><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p><ol start="78"><li>常见的异常类有哪些？</li></ol><p>NullPointerException 空指针异常</p><p>ClassNotFoundException 指定类不存在</p><p>NumberFormatException 字符串转换为数字异常</p><p>IndexOutOfBoundsException 数组下标越界异常</p><p>ClassCastException 数据类型转换异常</p><p>FileNotFoundException 文件未找到异常</p><p>NoSuchMethodException 方法不存在异常</p><p>IOException IO 异常</p><p>SocketException Socket 异常</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ol start="79"><li>http 响应码 301 和 302 代表的是什么？有什么区别？</li></ol><p>301：永久重定向。</p><p>302：暂时重定向。</p><p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p><ol start="80"><li>forward 和 redirect 的区别？</li></ol><p>forward 是转发 和 redirect 是重定向：</p><p>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</p><p>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</p><p>效率：forward 比 redirect 效率高。</p><ol start="81"><li>简述 tcp 和 udp 的区别？</li></ol><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和</p><p>细节控制交给应用的通信传输。</p><p>两者的区别大致如下：</p><p>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</p><p>tcp 提供可靠的服务（数据传输），udp 无法保证；</p><p>tcp 面向字节流，udp 面向报文；</p><p>tcp 数据传输慢，udp 数据传输快；</p><ol start="82"><li>tcp 为什么要三次握手，两次不行吗？为什么？</li></ol><p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端</p><p>的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握</p><p>手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务</p><p>器的资源。</p><ol start="83"><li>说一下 tcp 粘包是怎么产生的？</li></ol><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p><p>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</p><p>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。84. OSI 的七层模型都有哪些？</p><p>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</p><p>数据链路层：负责建立和管理节点间的链路。</p><p>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</p><p>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</p><p>会话层：向两个实体的表示层提供建立和使用连接的方法。</p><p>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</p><p>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</p><ol start="85"><li>get 和 post 请求有哪些区别？</li></ol><p>get 请求会被浏览器主动缓存，而 post 不会。</p><p>get 传递参数有大小限制，而 post 没有。</p><p>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</p><ol start="86"><li>如何实现跨域？</li></ol><p>实现跨域有以下几种方案：</p><p>服务器端运行跨域 设置 CORS 等于 *；</p><p>在单个接口使用注解 @CrossOrigin 运行跨域；</p><p>使用 jsonp 跨域；</p><ol start="87"><li>说一下 JSONP 实现原理？</li></ol><p>jsonp：JSON with Padding，它是利用 script 标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol start="88"><li>说一下你熟悉的设计模式？</li></ol><p>单例模式：保证被创建一次，节省系统开销。</p><p>工厂模式（简单工厂、抽象工厂）：解耦代码。</p><p>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</p><p>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</p><p>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</p><p>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p><ol start="89"><li>简单工厂和抽象工厂有什么区别？</li></ol><p>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</p><p>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</p><h2 id="Spring-x2F-Spring-MVC"><a href="#Spring-x2F-Spring-MVC" class="headerlink" title="Spring&#x2F;Spring MVC"></a>Spring&#x2F;Spring MVC</h2><ol start="90"><li>为什么要使用 spring？</li></ol><p>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</p><p>spring 提供了事务支持，使得事务操作变的更加方便。</p><p>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</p><p>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</p><ol start="91"><li>解释一下什么是 aop？</li></ol><p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p><p>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p><ol start="92"><li>解释一下什么是 ioc？</li></ol><p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由spring 来负责控制对象的生命周期和对象间的关系。</p><p>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p><ol start="93"><li>spring 有哪些主要模块？</li></ol><p>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</p><p>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</p><p>spring dao：Data Access Object 提供了 JDBC 的抽象层。</p><p>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</p><p>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</p><p>spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</p><ol start="94"><li>spring 常用的注入方式有哪些？</li></ol><p>setter 属性注入</p><p>构造方法注入</p><p>注解方式注入</p><ol start="95"><li>spring 中的 bean 是线程安全的吗？</li></ol><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p><p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，</p><p>所以就可以保证线程安全了。</p><p>有状态就是有数据存储功能。</p><p>无状态就是不会保存数据。96. spring 支持几种 bean 的作用域？</p><p>spring 支持 5 种作用域，如下：</p><p>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</p><p>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()</p><p>操作；</p><p>Web 环境下的作用域：</p><p>request：每次 http 请求都会创建一个 bean；</p><p>session：同一个 http session 共享一个 bean 实例；</p><p>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个</p><p>全局性的 http session。</p><p>注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><ol start="97"><li>spring 自动装配 bean 有哪些方式？</li></ol><p>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</p><p>byName：它根据 bean 的名称注入对象依赖项。</p><p>byType：它根据类型注入对象依赖项。</p><p>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</p><p>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</p><ol start="98"><li>spring 事务实现方式有哪些？</li></ol><p>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加@Transaction 注解）。</p><p>编码方式：提供编码的形式管理和维护事务。</p><ol start="99"><li>说一下 spring 的事务隔离？</li></ol><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p><p>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p><p>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p><p>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p><p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。不可重复读 ：是指在一个事务内，多次读同一数据。</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><ol start="100"><li>说一下 spring mvc 运行流程？</li></ol><p>spring mvc 先将请求发送给 DispatcherServlet。</p><p>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</p><p>DispatcherServlet 再把请求提交到对应的 Controller。</p><p>Controller 进行业务逻辑处理后，会返回一个 ModelAndView。</p><p>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</p><p>视图对象负责渲染返回给客户端。</p><ol start="101"><li>spring mvc 有哪些组件？</li></ol><p>前置控制器 DispatcherServlet。</p><p>映射控制器 HandlerMapping。</p><p>处理器 Controller。</p><p>模型和视图 ModelAndView。</p><p>视图解析器 ViewResolver。</p><ol start="102"><li>@RequestMapping 的作用是什么？</li></ol><p>将 http 请求映射到相应的类&#x2F;方法上。</p><ol start="103"><li>@Autowired 的作用是什么？</li></ol><p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set&#x2F;get 方法。</p><h2 id="Spring-Boot-x2F-Spring-Cloud"><a href="#Spring-Boot-x2F-Spring-Cloud" class="headerlink" title="Spring Boot&#x2F;Spring Cloud"></a>Spring Boot&#x2F;Spring Cloud</h2><ol start="104"><li>什么是 spring boot？</li></ol><p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p><ol start="105"><li>为什么要用 spring boot？</li></ol><p>配置简单</p><p>独立运行自动装配</p><p>无代码生成和 xml 配置</p><p>提供应用监控</p><p>易上手</p><p>提升开发效率</p><p>106.spring boot 核心配置文件是什么？</p><p>spring boot 核心的两个配置文件：</p><p>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</p><p>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</p><ol start="107"><li>spring boot 配置文件有哪几种类型？它们有什么区别？</li></ol><p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。</p><p>. properties 配置如下：</p><p>spring. RabbitMQ. port&#x3D;5672</p><p>. yml 配置如下：</p><p>spring:</p><p>RabbitMQ:</p><p>port: 5672</p><p>. yml 格式不支持 @PropertySource 注解导入。</p><ol start="108"><li>spring boot 有哪些方式可以实现热部署？</li></ol><p>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. </p><p>enabled 设置为 true；</p><p>使用 Intellij Idea 编辑器，沟上自动编译或手动重新编译。</p><ol start="109"><li>jpa 和 hibernate 有什么区别？</li></ol><p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p><ol start="110"><li>什么是 spring cloud？</li></ol><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用spring boot 的开发风格做到一键启动和部署。</p><ol start="111"><li>spring cloud 断路器的作用是什么？</li></ol><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p><ol start="112"><li>spring cloud 的核心组件有哪些？</li></ol><p>Eureka：服务注册于发现。</p><p>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</p><p>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</p><p>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</p><p>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</p><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><ol start="113"><li>为什么要使用 hibernate？</li></ol><p>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。</p><p>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。</p><p>可以很方便的进行数据库的移植工作。</p><p>提供了缓存机制，是程序执行更改的高效。</p><ol start="114"><li>什么是 ORM 框架？</li></ol><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</p><p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p><ol start="115"><li>hibernate 中如何在控制台查看打印的 SQL 语句？</li></ol><p>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p><ol start="116"><li>hibernate 有几种查询方式？</li></ol><p>三种：hql、原生 SQL、条件查询 Criteria。</p><ol start="117"><li>hibernate 实体类可以被定义为 final 吗？</li></ol><p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p><ol start="118"><li>在 hibernate 中使用 Integer 和 int 做映射有什么区别？</li></ol><p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p><ol start="119"><li>hibernate 是如何工作的？</li></ol><p>读取并解析配置文件。读取并解析映射文件，创建 SessionFactory。</p><p>打开 Session。</p><p>创建事务。</p><p>进行持久化操作。</p><p>提交事务。</p><p>关闭 Session。</p><p>关闭 SessionFactory。</p><ol start="120"><li>get()和 load()的区别？</li></ol><p>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。</p><p>load()支持延迟加载；get() 不支持延迟加载。</p><ol start="121"><li>说一下 hibernate 的缓存机制？</li></ol><p>hibernate 常用的缓存有一级缓存和二级缓存：</p><p>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身</p><p>维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷</p><p>出缓存；</p><p>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</p><ol start="122"><li>hibernate 对象有哪些状态？</li></ol><p>临时&#x2F;瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。</p><p>持久化状态：当调用 Session 的 save&#x2F;saveOrupdate&#x2F;get&#x2F;load&#x2F;list 等方法的时候，对象就是持久化状态。</p><p>游离状态：Session 关闭之后对象就是游离状态。</p><ol start="123"><li>在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</li></ol><p>getCurrentSession 会绑定当前线程，而 openSession 则不会。</p><p>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</p><ol start="124"><li>hibernate 实体类必须要有无参构造函数吗？为什么？</li></ol><p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><ol start="125"><li><p>MyBatis 中 #{}和 的区别是什么？#是预编译处理，{}的区别是什么？#{}是预编译处理，的区别是什么？#是预编译处理，{}是字符替换。 在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p></li><li><p>MyBatis 有几种分页方式？</p></li></ol><p>分页方式：逻辑分页和物理分页。</p><p>逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p><p>物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p><ol start="127"><li>RowBounds 是一次性查询全部结果吗？为什么？</li></ol><p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更的数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p><p>Fetch Size 官方相关文档：<a href="http://t/">http://t</a>. cn&#x2F;EfSE2g3</p><ol start="128"><li>MyBatis 逻辑分页和物理分页的区别是什么？</li></ol><p>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</p><p>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p><ol start="129"><li>MyBatis 是否支持延迟加载？延迟加载的原理是什么？</li></ol><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled&#x3D;true 即可。延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p><ol start="130"><li>说一下 MyBatis 的一级缓存和二级缓存？</li></ol><p>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</p><p>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个 SQLSession 之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列</p><p>化接口(可用来保存对象的状态)。</p><p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><p>缓存更新机制：当某一个作用域(一级缓存 Session&#x2F;二级缓存 Mapper)进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><ol start="131"><li>MyBatis 和 hibernate 的区别有哪些？</li></ol><p>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。</p><p>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。</p><p>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</p><p>132.MyBatis 有哪些执行器（Executor）？</p><p>MyBatis 有三种基本的 Executor 执行器：</p><p>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭</p><p>Statement 对象；</p><p>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存</p><p>在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用</p><p>Statement 对象；</p><p>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处</p><p>理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个</p><p>Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</p><ol start="133"><li>MyBatis 分页插件的实现原理是什么？</li></ol><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><ol start="134"><li>MyBatis 如何编写一个自定义插件？</li></ol><p>自定义插件实现原理</p><p>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、</p><p>ResultSetHandler）进行拦截：</p><p>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过</p><p>ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；</p><p>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另</p><p>外它也实现了 MyBatis 的一级缓存；</p><p>ParameterHandler：拦截参数的处理；</p><p>ResultSetHandler：拦截结果集的处理。</p><p>自定义插件实现关键</p><p>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interceptor</span> &#123;<br><br>Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable;<br><br>Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；</p><p>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return </p><p>Plugin. wrap(target, this)；</p><p>intercept 方法就是要进行拦截的时候要执行的方法。</p><p>自定义插件实现示例</p><p>官方插件实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;@Signature(type = Executor. class, method = “query”,</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">args = &#123;MappedStatement. class, Object. class, RowBounds. class, ResultHandler. class&#125;)&#125;)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> invocation. getTarget(); <span class="hljs-comment">//被代理对象</span><br><br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> invocation. getMethod(); <span class="hljs-comment">//代理方法</span><br><br>Object[] args = invocation. getArgs(); <span class="hljs-comment">//方法参数</span><br><br><span class="hljs-comment">// do something . . . . . . 方法拦截前执行代码块</span><br><br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation. proceed();<br><br><span class="hljs-comment">// do something . . . . . . . 方法拦截后执行代码块</span><br><br><span class="hljs-keyword">return</span> result;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span> &#123;<br><br><span class="hljs-keyword">return</span> Plugin. wrap(target, <span class="hljs-built_in">this</span>);<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ol start="135"><li>RabbitMQ 的使用场景有哪些？</li></ol><p>抢购活动，削峰填谷，防止系统崩塌。</p><p>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。</p><p>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p><ol start="136"><li>RabbitMQ 有哪些重要的角色？</li></ol><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：生产者：消息的创建者，负责创建和推送数据到消息服务器；</p><p>消费者：消息的接收方，用于处理数据和确认消息；</p><p>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</p><ol start="137"><li>RabbitMQ 有哪些重要的组件？</li></ol><p>ConnectionFactory（连接管理器）：应用程序与 Rabbit 之间建立连接的管理器，程序代码中使用。</p><p>Channel（信道）：消息推送使用的通道。</p><p>Exchange（交换器）：用于接受、分配消息。</p><p>Queue（队列）：用于存储生产者的消息。</p><p>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</p><p>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</p><ol start="138"><li>RabbitMQ 中 vhost 的作用是什么？</li></ol><p>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p><ol start="139"><li>RabbitMQ 的消息是怎么发送的？</li></ol><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p><ol start="140"><li>RabbitMQ 怎么保证消息的稳定性？</li></ol><p>提供了事务的功能。</p><p>通过将 channel 设置为 confirm（确认）模式。</p><ol start="141"><li>RabbitMQ 怎么避免消息丢失？</li></ol><p>把消息持久化磁盘，保证服务器重启消息不丢失。</p><p>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</p><ol start="142"><li>要保证消息持久化成功的条件有哪些？</li></ol><p>声明队列必须设置持久化 durable 设置为 true.</p><p>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</p><p>消息已经到达持久化交换器。</p><p>消息已经到达持久化队列。</p><p>以上四个条件都满足才能保证消息持久化成功。143. RabbitMQ 持久化有什么缺点？</p><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p><ol start="144"><li>RabbitMQ 有几种广播类型？</li></ol><p>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。</p><p>headers：与 direct 类似，只是性能很差，此类型几乎用不到。</p><p>fanout：分发模式，把消费分发给所有订阅者。</p><p>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</p><ol start="145"><li>RabbitMQ 怎么实现延迟消息队列？</li></ol><p>延迟队列的实现有两种方式：</p><p>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</p><p>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</p><ol start="146"><li>RabbitMQ 集群有什么用？</li></ol><p>集群主要有以下两个用途：</p><p>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</p><p>高容量：集群可以承载更多的消息量。</p><ol start="147"><li>RabbitMQ 节点的类型有哪些？</li></ol><p>磁盘节点：消息会存储到磁盘。</p><p>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</p><ol start="148"><li>RabbitMQ 集群搭建需要注意哪些问题？</li></ol><p>各节点之间使用“–link”连接，此属性不能忽略。</p><p>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</p><p>整个集群中必须包含一个磁盘节点。</p><ol start="149"><li>RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</li></ol><p>不是，原因有以下两个：</p><p>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</p><p>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</p><ol start="150"><li>RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</li></ol><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><p>不能创建队列</p><p>不能创建交换器</p><p>不能创建绑定</p><p>不能添加用户</p><p>不能更改权限</p><p>不能添加和删除集群节点</p><p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p><ol start="151"><li>RabbitMQ 对集群节点停止顺序有要求吗？</li></ol><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ol start="152"><li>kafka 可以脱离 zookeeper 单独使用吗？为什么？</li></ol><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p><ol start="153"><li>kafka 有几种数据保留的策略？</li></ol><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p><ol start="154"><li>kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</li></ol><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p><ol start="155"><li>什么情况会导致 kafka 运行变慢？</li></ol><p>cpu 性能瓶颈</p><p>磁盘读写瓶颈</p><p>网络瓶颈</p><ol start="156"><li>使用 kafka 集群需要注意什么？</li></ol><p>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><ol start="157"><li>zookeeper 是什么？</li></ol><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><ol start="158"><li>zookeeper 都有哪些功能？</li></ol><p>集群管理：监控节点存活状态、运行请求等。</p><p>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</p><p>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。</p><p>zookeeper 可以对分布式锁进行控制。</p><p>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p><ol start="159"><li>zookeeper 有几种部署模式？</li></ol><p>zookeeper 有三种部署模式：</p><p>单机部署：一台集群上运行；</p><p>集群部署：多台集群运行；</p><p>伪集群部署：一台集群启动多个 zookeeper 实例运行。</p><ol start="160"><li>zookeeper 怎么保证主从节点的状态同步？</li></ol><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><ol start="161"><li>集群中为什么要有主节点？</li></ol><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><ol start="162"><li>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</li></ol><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p><ol start="163"><li>说一下 zookeeper 的通知机制？</li></ol><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ol start="164"><li>数据库的三范式是什么？</li></ol><p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</p><p>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</p><p>第三范式：任何非主属性不依赖于其它非主属性。</p><ol start="165"><li>一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</li></ol><p>表类型如果是 MyISAM ，那 id 就是 8。</p><p>表类型如果是 InnoDB，那 id 就是 6。</p><p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p><ol start="166"><li>如何获取当前数据库版本？</li></ol><p>使用 select version() 获取当前 MySQL 数据库版本。</p><ol start="167"><li>说一下 ACID 是什么？</li></ol><p>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</p><p>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</p><p>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p><p>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><ol start="168"><li>char 和 varchar 的区别是什么？</li></ol><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p><p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p><p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p><ol start="169"><li>float 和 double 的区别是什么？</li></ol><p>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</p><p>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p><ol start="170"><li>MySQL 的内连接、左连接、右连接有什么区别？</li></ol><p>内连接关键字：inner join；左连接：left join；右连接：right join。内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><ol start="171"><li>MySQL 索引是怎么实现的？</li></ol><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所以索引的性能也是更好的。</p><ol start="172"><li>怎么验证 MySQL 的索引是否满足需求？</li></ol><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p><p>explain 语法：explain select * from table where type&#x3D;1。</p><ol start="173"><li>说一下数据库的事务隔离？</li></ol><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</p><p>transaction-isolation &#x3D; REPEATABLE-READ</p><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><p>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</p><p>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</p><p>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</p><p>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p>不可重复读 ：是指在一个事务内，多次读同一数据。</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个</p><p>事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><ol start="174"><li>说一下 MySQL 常用的引擎？</li></ol><p>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p><p>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更</p><p>新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><ol start="175"><li>说一下 MySQL 的行锁和表锁？</li></ol><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p><p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</p><p>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p><ol start="176"><li>说一下乐观锁和悲观锁？</li></ol><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p><p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p><p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><ol start="177"><li>MySQL 问题排查都有哪些手段？</li></ol><p>使用 show processlist 命令查看当前所有连接信息。</p><p>使用 explain 命令查询 SQL 语句执行计划。</p><p>开启慢查询日志，查看慢查询的 SQL。</p><ol start="178"><li>如何做 MySQL 的性能优化？</li></ol><p>为搜索字段创建索引。</p><p>避免使用 select *，列出需要查询的字段。</p><p>垂直分割分表。</p><p>选择正确的存储引擎。</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ol start="179"><li>Redis 是什么？都有哪些使用场景？</li></ol><p>Redis 是一个使用 C 语言开发的高速缓存数据库。</p><p>Redis 使用场景：</p><p>记录帖子点赞数、点击数、评论数；</p><p>缓存近期热帖；</p><p>缓存文章详情信息；</p><p>记录用户会话信息。</p><ol start="180"><li>Redis 有哪些功能？</li></ol><p>数据缓存功能</p><p>分布式锁的功能</p><p>支持数据持久化</p><p>支持事务</p><p>支持消息队列</p><ol start="181"><li>Redis 和 memcache 有什么区别？</li></ol><p>存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。</p><p>数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。</p><p>使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p><p>value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。</p><ol start="182"><li>Redis 为什么是单线程的？</li></ol><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p><p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p><ol start="183"><li>什么是缓存穿透？怎么解决？</li></ol><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p><p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><ol start="184"><li>Redis 支持的数据类型有哪些？</li></ol><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p><ol start="185"><li>Redis 支持的 Java 客户端都有哪些？</li></ol><p>支持的 Java 客户端有 Redisson、jedis、lettuce 等。</p><ol start="186"><li>jedis 和 Redisson 有哪些区别？</li></ol><p>jedis：提供了比较全面的 Redis 命令的支持。</p><p>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</p><ol start="187"><li>怎么保证缓存和数据库数据的一致性？</li></ol><p>合理设置缓存的过期时间。</p><p>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</p><ol start="188"><li>Redis 持久化有几种方式？</li></ol><p>Redis 的持久化有两种方式，或者说有两种策略：</p><p>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</p><p>AOF（Append Only File）：每一个收到的写命令都通过 write 函数追加到文件中。</p><ol start="189"><li>Redis 怎么实现分布式锁？</li></ol><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p><ol start="190"><li>Redis 分布式锁有什么缺陷？</li></ol><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p><ol start="191"><li>Redis 如何做内存优化？</li></ol><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p><ol start="192"><li>Redis 淘汰策略有哪些？</li></ol><p>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</p><p>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</p><p>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</p><p>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</p><p>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</p><p>no-enviction（驱逐）：禁止驱逐数据。</p><ol start="193"><li>Redis 常见的性能问题有哪些？该如何解决？</li></ol><p>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</p><p>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol start="194"><li>说一下 JVM 的主要组成部分？及其作用？</li></ol><p>类加载器（ClassLoader）</p><p>运行时数据区（Runtime Data Area）</p><p>执行引擎（Execution Engine）</p><p>本地库接口（Native Interface）</p><p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><ol start="195"><li>说一下 JVM 运行时数据区？</li></ol><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</p><p>Java虚拟机栈（Java Virtual MachineStacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</p><p>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</p><p>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</p><p>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p><ol start="196"><li>说一下堆栈的区别？</li></ol><p>功能方面：堆是用来存放对象的，栈是用来执行程序的。</p><p>共享性：堆是线程共享的，栈是线程私有的。</p><p>空间大小：堆大小远远大于栈。</p><p>197.队列和栈是什么？有什么区别？</p><p>队列和栈都是被用来预存储数据的。</p><p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。栈和队列很相似，但它运行对元素进行后进先出进行检索。</p><ol start="198"><li>什么是双亲委派模型？</li></ol><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p><p>类加载器分类：</p><p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载 Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</p><p>其他类加载器：</p><p>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext 目录或 Java. ext. dirs 系统变量指定的路径中的所有类库；</p><p>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p><p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><ol start="199"><li>说一下类加载的执行过程？</li></ol><p>类加载分为以下 5 个步骤：</p><p>加载：根据查找路径找到相应的 class 文件然后导入；</p><p>检查：检查加载的 class 文件的正确性；</p><p>准备：给类中的静态变量分配内存空间；</p><p>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</p><p>初始化：对静态变量和静态代码块执行初始化工作。</p><ol start="200"><li>怎么判断对象是否可以被回收？</li></ol><p>一般有两种方法来判断：</p><p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</p><p>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p><ol start="201"><li>Java 中都有哪些引用类型？</li></ol><p>强引用：发生 gc 的时候不会被回收。</p><p>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。弱引用：有用但不是必须的对象，在下一次 GC 时会被回收。</p><p>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p><ol start="202"><li>说一下 JVM 有哪些垃圾回收算法？</li></ol><p>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</p><p>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p><p>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</p><p>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p><ol start="203"><li>说一下 JVM 有哪些垃圾回收器？</li></ol><p>Serial：最早的单线程串行垃圾回收器。</p><p>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</p><p>ParNew：是 Serial 的多线程版本。</p><p>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</p><p>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</p><p>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B&#x2F;S 系统。</p><p>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p><ol start="204"><li>详细介绍一下 CMS 垃圾回收器？</li></ol><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><ol start="205"><li>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</li></ol><p>新生代回收器：Serial、ParNew、Parallel Scavenge</p><p>老年代回收器：Serial Old、Parallel Old、CMS</p><p>整堆回收器：G1</p><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><ol start="206"><li>简述分代垃圾回收器是怎么工作的？</li></ol><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老生代的默认占比是2&#x2F;3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</p><p>清空 Eden 和 From Survivor 分区；</p><p>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</p><p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><ol start="207"><li>说一下 JVM 调优的工具？</li></ol><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</p><p>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、</p><p>gc 变化等。</p><ol start="208"><li>常用的 JVM 调优的参数都有哪些？</li></ol><p>-Xms2g：初始化推大小为 2g； </p><p>-Xmx2g：堆最大内存为 2g； </p><p>-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4； </p><p>-XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2； </p><p>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</p><p>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</p><p>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</p><p>-XX:+PrintGC：开启打印 gc 信息；</p><p>-XX:+PrintGCDetails：打印 gc 详细信息。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GitHub高效找开源项目</title>
    <link href="/2022/06/29/GitHub%E9%AB%98%E6%95%88%E6%89%BE%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/06/29/GitHub%E9%AB%98%E6%95%88%E6%89%BE%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>根据名字搜索：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">in</span>:name spring boot stars:&gt;<span class="hljs-number">3000</span> forks:&gt;<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>根据详情搜索</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">in</span>:readme spring boot stars:&gt;<span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><p>根据描述里面搜索</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">in</span>:description 微服务 language:java pushed:&gt;<span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker(1)</title>
    <link href="/2022/06/28/Docker(%E4%B8%80)/"/>
    <url>/2022/06/28/Docker(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>开发和运维之间因为环境不同而导致的矛盾</p><p>集群环境下每台机器部署相同的应用</p><p>DevOps(Development and Operations)</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到 任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p><p>Docker是世界领先的软件容器平台。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。 运维人员利用 Docker 可以在隔离容器中并行运行和管理应用，获得更好的计算密度。企业利用 Docker 可以构建敏 捷的软件交付管道，以更快的速度、更高的安全性和可靠的信誉为 Linux 和 Windows Server 应用发布新功能。</p><p><img src="https://cdn.jsdelivr.net/gh/ltx1998/images/2022-6-22/202206220925740.jpg" alt="docker1-2"></p><h3 id="Docker优点"><a href="#Docker优点" class="headerlink" title="Docker优点"></a>Docker优点</h3><p>简化程序： Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管 理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的任务，在Docker容器的处理下，只需要数秒就 能完成。</p><p>避免选择恐惧症： 如果你有选择恐惧症，还是资深患者。Docker 帮你打包你的纠结！比如 Docker 镜像；Docker 镜 像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应 用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。</p><p>节省开支： 一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高 价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化 的方式。</p><h3 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h3><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于原生</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般是几十个</td></tr></tbody></table><h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p>Docker使用C&#x2F;S架构，Client通过接口与Server进程通信实现容器的构建，运行和发布，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ltx1998/images/2022-6-22/202206220926139.jpg" alt="docker1-2"></p><h3 id="Host-Docker-宿主机"><a href="#Host-Docker-宿主机" class="headerlink" title="Host(Docker 宿主机)"></a>Host(Docker 宿主机)</h3><p>安装了Docker程序，并运行了Docker daemon的主机。</p><h3 id="Docker-daemon-Docker-守护进程"><a href="#Docker-daemon-Docker-守护进程" class="headerlink" title="Docker daemon(Docker 守护进程)"></a>Docker daemon(Docker 守护进程)</h3><p>运行在宿主机上，Docker守护进程，用户通过Docker client(Docker命令)与Docker daemon交互。</p><h3 id="Images-镜像"><a href="#Images-镜像" class="headerlink" title="Images(镜像)"></a>Images(镜像)</h3><p>将软件环境打包好的模板，用来创建容器的，一个镜像可以创建多个容器。</p><p>镜像分层结构:</p><p>位于下层的镜像称为父镜像(Parent Image)，最底层的称为基础镜像(Base Image)。</p><p>最上层为“可读写”层，其下的均为“只读”层。</p><p>AUFS:</p><ul><li><p>advanced multi-layered unification filesystem：高级多层统一文件系统</p></li><li><p>用于为Linux文件系统实现“联合挂载</p></li><li><p>AUFS是之前的UnionFS的重新实现</p></li><li><p>Docker最初使用AUFS作为容器文件系统层</p></li><li><p>AUFS的竞争产品是overlayFS，从3.18开始被合并入Linux内核</p></li><li><p>Docker的分层镜像，除了AUFS，Docker还支持btrfs，devicemapper和vfs等</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ltx1998/images/2022-6-22/202206220926972.jpg" alt="docker1-3"></p><h3 id="Containers-容器"><a href="#Containers-容器" class="headerlink" title="Containers(容器)"></a>Containers(容器)</h3><p>Docker的运行组件，启动一个镜像就是一个容器，容器与容器之间相互隔离，并且互不影响。</p><h3 id="Docker-Client-Docker-客户端"><a href="#Docker-Client-Docker-客户端" class="headerlink" title="Docker Client(Docker 客户端)"></a>Docker Client(Docker 客户端)</h3><p>Docker命令行工具，用户是用Docker Client与Docker daemon进行通信并返回结果给用户。也可以使用其他工具通 过<a href="https://docs.docker.com/engine/api/sdk/">Docker Api</a> 与Docker daemon通信。</p><h3 id="Registry-仓库服务注册"><a href="#Registry-仓库服务注册" class="headerlink" title="Registry(仓库服务注册)"></a>Registry(仓库服务注册)</h3><p>经常会和仓库(Repository)混为一谈，实际上Registry上可以有多个仓库，每个仓库可以看成是一个用户，一个用户 的仓库放了多个镜像。仓库分为了公开仓库(Public Repository)和私有仓库(Private Repository)，最大的公开仓库是 官方的Docker Hub，国内也有如阿里云、时速云等，可以给国内用户提供稳定快速的服务。用户也可以在本地网络 内创建一个私有仓库。当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次 在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p><h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><p>Docker 提供了两个版本：社区版 (CE) 和企业版 (EE)。</p><h3 id="操作系统要求"><a href="#操作系统要求" class="headerlink" title="操作系统要求"></a>操作系统要求</h3><p>以Centos7为例，且Docker 要求操作系统必须为64位，且centos内核版本为3.1及以上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看系统内核版本信息</span><br>uname -r<br></code></pre></td></tr></table></figure><h3 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h3><p>卸载旧版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum list installed | grep docker<br>yum -y remove ...<br></code></pre></td></tr></table></figure><p>卸载后将保留 &#x2F;var&#x2F;lib&#x2F;docker 的内容（镜像、容器、存储卷和网络等）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf /var/lib/docker<br></code></pre></td></tr></table></figure><p>1.安装依赖软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y yum-utils device-mapper-persistent-data lvm2<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装前可查看device-mapper-persistent-data和lvm2是否已经安装</span><br>rpm -qa|grep device-mapper-persistent-data<br>rpm -qa|grep lvm2<br></code></pre></td></tr></table></figure><p>2.设置yum源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br>yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">清华大学源 https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">阿里云镜像源 https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></code></pre></td></tr></table></figure><p>3.更新yum软件包索引</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum makecache fast<br></code></pre></td></tr></table></figure><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><p>安装最新版本docker-ce</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install docker-ce -y<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装指定版本docker-ce可使用以下命令查看</span><br>yum list docker-ce.x86_64 --showduplicates | sort -r<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装完成之后可以使用命令查看</span><br>docker version<br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动</span><br>systemctl start docker<br><span class="hljs-meta prompt_">#</span><span class="language-bash">开机自动启动</span><br>systemctl enable docker<br></code></pre></td></tr></table></figure><h3 id="三、配置镜像加速"><a href="#三、配置镜像加速" class="headerlink" title="三、配置镜像加速"></a>三、配置镜像加速</h3><p>这里使用阿里云的免费镜像加速服务，也可以使用其他如时速云、网易云等</p><p>1.注册登录开通阿里云<a href="https://cr.console.aliyun.com/cn-beijing/instances/repositories">容器镜像服务</a></p><p>2.查看控制台，招到镜像加速器并复制自己的加速器地址</p><p>3.找到&#x2F;etc&#x2F;docker目录下的daemon.json文件，没有则直接输入命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi daemon.json<br></code></pre></td></tr></table></figure><p>4.加入以下配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">填写自己的加速器地址</span><br>&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://zfzbet67.mirror.aliyuncs.com&quot;]<br>&#125;<br></code></pre></td></tr></table></figure><p>5.通知systemd重载此配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>6.重启docker服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="Docker常用操作"><a href="#Docker常用操作" class="headerlink" title="Docker常用操作"></a>Docker常用操作</h2><p>输入<code>docker</code>可以查看Docker的命令用法，输入<code>docker COMMAND --help</code>查看指定命令详细用法。</p><h3 id="镜像常用操作"><a href="#镜像常用操作" class="headerlink" title="镜像常用操作"></a>镜像常用操作</h3><p>查找镜像:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">搜索docker hub网站镜像的详细信息</span><br>docker search 关键词<br></code></pre></td></tr></table></figure><p>下载镜像:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">Tag表示版本，有些镜像的版本显示latest，为最新版本</span><br>docker pull 镜像名:TAG<br></code></pre></td></tr></table></figure><p>查看镜像:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看本地所有镜像</span><br>docker images<br></code></pre></td></tr></table></figure><p>删除镜像:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">删除指定本地镜像</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-f 表示强制删除</span><br>docker rmi -f 镜像ID或者镜像名:TAG<br></code></pre></td></tr></table></figure><p>获取元信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">获取镜像的元信息，详细信息</span><br>docker inspect 镜像ID或者镜像名:TAG<br></code></pre></td></tr></table></figure><h3 id="容器常用操作"><a href="#容器常用操作" class="headerlink" title="容器常用操作"></a>容器常用操作</h3><p>运行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">--name 指定容器名，可自定义，不指定自动命名</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-i 以交互模式运行容器</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-t 分配一个伪终端，即命令行，通常-it组合来使用</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-p 指定映射端口，讲主机端口映射到容器内的端口</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-d 后台运行容器</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-v 指定挂载主机目录到容器目录，默认为rw读写模式，ro表示只读</span><br>docker run --name 容器名 -i -t -p 主机端口:容器端口 -d -v 主机目录:容器目录:ro 镜像ID或镜像名:TAG<br></code></pre></td></tr></table></figure><p>容器列表:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">docker ps查看正在运行的容器</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-a 查看所有容器（运行中、未运行）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-q 只查看容器的ID</span><br>docker ps -a -q<br></code></pre></td></tr></table></figure><p>启动容器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start 容器ID或容器名<br></code></pre></td></tr></table></figure><p>停止容器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop 容器ID或容器名<br></code></pre></td></tr></table></figure><p>删除容器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">-f 表示强制删除</span><br>docker rm -f 容器ID或容器名<br></code></pre></td></tr></table></figure><p>查看日志:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs 容器ID或容器名<br></code></pre></td></tr></table></figure><p>进入正在运行容器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">进入正在运行的容器并且开启交互模式终端</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">/bin/bash是固有写法，作用是因为docker后台必须运行一个进程，否则容器就会退出，在这里表示启动容器后启动bash。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">也可以用docker <span class="hljs-built_in">exec</span>在运行中的容器执行命令</span><br>docker exec -it 容器ID或者容器名 /bin/bash<br></code></pre></td></tr></table></figure><p>拷贝文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp 主机文件路径 容器ID或容器名:容器路径 #主机中文件拷贝到容器中<br>docker cp 容器ID或容器名:容器路径 主机文件路径 #容器中文件拷贝到主机中<br>docker mv 文件 移动后的文件路径  #移动文件<br>exit 退出容器<br></code></pre></td></tr></table></figure><p>获取容器元信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect 容器ID或容器名<br></code></pre></td></tr></table></figure><h3 id="Docker容器生命周期"><a href="#Docker容器生命周期" class="headerlink" title="Docker容器生命周期"></a>Docker容器生命周期</h3><p><img src="https://cdn.jsdelivr.net/gh/ltx1998/images/2022-6-22/202206220926543.jpg" alt="Docker Container Event And State"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker(2)</title>
    <link href="/2022/06/28/Docker(%E4%BA%8C)/"/>
    <url>/2022/06/28/Docker(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker生成镜像的两种方式"><a href="#Docker生成镜像的两种方式" class="headerlink" title="Docker生成镜像的两种方式"></a>Docker生成镜像的两种方式</h1><p>有时候从Docker镜像仓库中下载的镜像不能满足要求，我们可以基于一个基础镜像构建一个自己的镜像</p><p>两种方式：</p><ul><li>更新镜像：使用<code>docker commit</code>命令</li><li>构建镜像：使用<code>docker build</code>命令，需要创建Dockerfile文件</li></ul><h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h2><p>先使用基础镜像创建一个容器，然后对容器内容进行更改，然后使用<code>docker commit</code>命令提交为一个新的镜像（以tomcat为例）。</p><p>1.根据基础镜像，创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name mytomcat -p 80:8080 -d tomcat<br></code></pre></td></tr></table></figure><p>2.修改容器内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it mytomcat /bin/bash<br>cd webapps/ROOT<br>rm -f index.jsp<br>echo hello world &gt; index.html<br>exit<br></code></pre></td></tr></table></figure><p>3.提交为新镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit -m=&quot;描述消息&quot; -a=&quot;作者&quot; 容器ID或容器名 镜像名:TAG<br><span class="hljs-meta prompt_"># </span><span class="language-bash">例:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker commit -m=<span class="hljs-string">&quot;修改了首页&quot;</span> -a=<span class="hljs-string">&quot;华安&quot;</span> mytomcat huaan/tomcat:v1.0</span><br></code></pre></td></tr></table></figure><p>4.使用新镜像运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name tom -p 8080:8080 -d huaan/tomcat:v1.0<br></code></pre></td></tr></table></figure><h2 id="使用Dockerfile构建镜像"><a href="#使用Dockerfile构建镜像" class="headerlink" title="使用Dockerfile构建镜像"></a>使用Dockerfile构建镜像</h2><h3 id="什么是Dockerfile？"><a href="#什么是Dockerfile？" class="headerlink" title="什么是Dockerfile？"></a>什么是Dockerfile？</h3><p>Dockerfile is nothing but the source code for building Docker images</p><ul><li><p>Docker can build images automatically by reading the instructions from a Dockerfile</p></li><li><p>A Dockerfile is a <strong>text document</strong> that contains all the commands a user could call on the command line to assemble an image</p><ul><li>Using <strong>docker build</strong> users can create an automated build that executes several command-line instructions in succession</li></ul></li></ul><h3 id="Dockerfile格式"><a href="#Dockerfile格式" class="headerlink" title="Dockerfile格式"></a>Dockerfile格式</h3><ul><li><p>Format：</p><ul><li>#Comment</li><li>INSTRUCTION arguments</li></ul></li><li><p>The instruction is not case-sensitive</p><ul><li>However,convention is for them to be UPPERCASE to distinguish them from arguments more easily</li></ul></li><li><p>Docker runs instructions in a Dockerfile in order</p></li><li><p>The first instruction must be ‘FROM’ in order to specify the Base Image from which you are building</p></li></ul><h3 id="使用Dockerfile构建SpringBoot应用镜像"><a href="#使用Dockerfile构建SpringBoot应用镜像" class="headerlink" title="使用Dockerfile构建SpringBoot应用镜像"></a>使用Dockerfile构建SpringBoot应用镜像</h3><p>一、准备</p><p>1.把你的springboot项目打包成可执行jar包</p><p>2.把jar包上传到Linux服务器</p><p>二、构建</p><p>1.在jar包路径下创建Dockerfile文件<code>vi Dockerfile</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 指定基础镜像，本地没有会从dockerHub pull下来</span><br><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><br><span class="hljs-comment">#作者</span><br><span class="hljs-keyword">MAINTAINER</span> huaan<br><span class="hljs-comment"># 把可执行jar包复制到基础镜像的根目录下</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> demo.jar /demo.jar</span><br><span class="hljs-comment"># 镜像要暴露的端口，如要使用端口，在执行docker run命令时使用-p生效</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><span class="hljs-comment"># 在镜像运行为容器后执行的命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/demo.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>2.使用<code>docker build</code>命令构建镜像，基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t huaan/mypro:v1 .<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-f指定Dockerfile文件的路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-t指定镜像名字和TAG</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">.指当前目录，这里实际上需要一个上下文路径</span><br></code></pre></td></tr></table></figure><p>三、运行</p><p>运行自己的SpringBoot镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name pro -p 80:80 -d 镜像名:TAG<br></code></pre></td></tr></table></figure><h3 id="Dockerfile常用指令"><a href="#Dockerfile常用指令" class="headerlink" title="Dockerfile常用指令"></a>Dockerfile常用指令</h3><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>FROM指令是最重要的一个并且必须为Dockerfile文件开篇的第一个非注释行，用于为镜像文件构建过程指定基础镜像，后续的指令运行于此基础镜像提供的运行环境</p><p>这个基础镜像可以是任何可用镜像，默认情况下docker build会从本地仓库找指定的镜像文件，如果不存在就会从Docker Hub(配置的加速源)上拉取</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> &lt;image&gt;<br><span class="hljs-keyword">FROM</span> &lt;image&gt;:&lt;tag&gt;<br><span class="hljs-keyword">FROM</span> &lt;image&gt;@&lt;digest&gt;<br></code></pre></td></tr></table></figure><h4 id="MAINTAINER-depreacted"><a href="#MAINTAINER-depreacted" class="headerlink" title="MAINTAINER(depreacted)"></a>MAINTAINER(depreacted)</h4><p>Dockerfile的制作者提供的本人详细信息</p><p>Dockerfile不限制MAINTAINER出现的位置，但是推荐放到FROM指令之后</p><p>语法：</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">MAINTAINER</span> &lt;name&gt;<br></code></pre></td></tr></table></figure><p>name可以是任何文本信息，一般用作者名称或者邮箱</p><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>给镜像指定各种元数据</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;...</span><br></code></pre></td></tr></table></figure><p>一个Dockerfile可以写多个LABEL，但是不推荐这么做，Dockerfile每一条指令都会生成一层镜像，如果LABEL太长可以使用\符号换行。构建的镜像会继承基础镜像的LABEL，并且会去掉重复的，但如果值不同，则后面的值会覆盖前面的值。</p><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>用于从宿主机复制文件到创建的新镜像文件</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> &lt;src&gt;...&lt;dest&gt;</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,...<span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]</span><br><span class="hljs-comment"># &lt;src&gt;：要复制的源文件或者目录，可以使用通配符</span><br><span class="hljs-comment"># &lt;dest&gt;：目标路径，即正在创建的image的文件系统路径；建议&lt;dest&gt;使用绝对路径，否则COPY指令则以WORKDIR为其起始路径</span><br></code></pre></td></tr></table></figure><p>注意：如果你的路径中有空白字符，通常会使用第二种格式</p><p>规则：</p><ul><li><code>&lt;src&gt;</code>必须是build上下文中的路径，不能是其父目录中的文件</li><li>如果<code>&lt;src&gt;</code>是目录，则其内部文件或子目录会被递归复制，但<code>&lt;src&gt;</code>目录自身不会被复制</li><li>如果指定了多个<code>&lt;src&gt;</code>，或在<code>&lt;src&gt;</code>中使用了通配符，则<code>&lt;dest&gt;</code>必须是一个目录，则必须以&#x2F;符号结尾</li><li>如果<code>&lt;dest&gt;</code>不存在，将会被自动创建，包括其父目录路径</li></ul><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>基本用法和COPY指令一样，ADD支持使用TAR文件和URL路径</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ADD</span><span class="language-bash"> &lt;src&gt;...&lt;dest&gt;</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,...<span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>规则：</p><ul><li>和COPY规则相同</li><li>如果<code>&lt;src&gt;</code>为URL并且<code>&lt;dest&gt;</code>没有以&#x2F;结尾，则<code>&lt;src&gt;</code>指定的文件将被下载到<code>&lt;dest&gt;</code></li><li>如果<code>&lt;src&gt;</code>是一个本地系统上压缩格式的tar文件，它会展开成一个目录；但是通过URL获取的tar文件不会自动展开</li><li>如果<code>&lt;src&gt;</code>有多个，直接或间接使用了通配符指定多个资源，则<code>&lt;dest&gt;</code>必须是目录并且以&#x2F;结尾</li></ul><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>用于为Dockerfile中所有的RUN、CMD、ENTRYPOINT、COPY和ADD指定设定工作目录，只会影响当前WORKDIR之后的指令。</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> &lt;dirpath&gt;</span><br></code></pre></td></tr></table></figure><p>在Dockerfile文件中，WORKDIR可以出现多次，路径可以是相对路径，但是它是相对于前一个WORKDIR指令指定的路径</p><p>另外，WORKDIR可以是ENV指定定义的变量</p><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>用来创建挂载点，可以挂载宿主机上的卷或者其他容器上的卷</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> &lt;mountpoint&gt;</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;mountpoint&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>不能指定宿主机当中的目录，宿主机挂载的目录是自动生成的</p><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>用于给容器打开指定要监听的端口以实现和外部通信</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> &lt;port&gt;[/&lt;protocol&gt;] [&lt;port&gt;[/&lt;protocol&gt;]...]<br></code></pre></td></tr></table></figure><p><code>&lt;protocol&gt;</code>用于指定传输层协议，可以是TCP或者UDP，默认是TCP协议</p><p>EXPOSE可以一次性指定多个端口，例如：<code>EXPOSE 80/tcp 80/udp</code></p><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>用来给镜像定义所需要的环境变量，并且可以被Dockerfile文件中位于其后的其他指令(如ENV、ADD、COPY等)所调用，调用格式：$variable_name或者${variable_name}</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> &lt;key&gt;=&lt;value&gt;...<br></code></pre></td></tr></table></figure><p>第一种格式中，<code>&lt;key&gt;</code>之后的所有内容都会被视为<code>&lt;value&gt;</code>的组成部分，所以一次只能设置一个变量</p><p>第二种格式可以一次设置多个变量，如果<code>&lt;value&gt;</code>当中有空格可以使用\进行转义或者对<code>&lt;value&gt;</code>加引号进行标识；另外\也可以用来续行</p><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p>用法同ENV</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]<br></code></pre></td></tr></table></figure><p>指定一个变量，可以在docker build创建镜像的时候，使用<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>来指定参数</p><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>用来指定docker build过程中运行指定的命令</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;<span class="hljs-built_in">command</span>&gt;</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;executable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>第一种格式里面的参数一般是一个shell命令，以<code>/bin/sh -c</code>来运行它</p><p>第二种格式中的参数是一个JSON格式的数组，当中<code>&lt;executable&gt;</code>是要运行的命令，后面是传递给命令的选项或者参数；但是这种格式不会用<code>/bin/sh -c</code>来发起，所以常见的shell操作像变量替换和通配符替换不会进行；如果你运行的命令依赖shell特性，可以替换成类型以下的格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;&lt;executable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>容器启动时运行的命令</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> &lt;<span class="hljs-built_in">command</span>&gt;</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;executable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>前两种语法和RUN相同</p><p>第三种语法用于为ENTRYPOINT指令提供默认参数</p><p>RUN和CMD区别：</p><ul><li>RUN指令运行于镜像文件构建过程中，CMD则运行于基于Dockerfile构建出的新镜像文件启动为一个容器的时候</li><li>CMD指令的主要目的在于给启动的容器指定默认要运行的程序，且在运行结束后，容器也将终止；不过，CMD命令可以被docker run的命令行选项给覆盖</li><li>Dockerfile中可以存在多个CMD指令，但是只有最后一个会生效</li></ul><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>类似于CMD指令功能，用于给容器指定默认运行程序</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash">&lt;<span class="hljs-built_in">command</span>&gt;</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash">[<span class="hljs-string">&quot;&lt;executable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>和CMD不同的是ENTRYPOINT启动的程序不会被docker run命令指定的参数所覆盖，而且，这些命令行参数会被当做参数传递给ENTRYPOINT指定的程序(但是，docker run命令的–entrypoint参数可以覆盖ENTRYPOINT)</p><p>docker run命令传入的参数会覆盖CMD指令的内容并且附加到ENTRYPOINT命令最后作为其参数使用</p><p>同样，Dockerfile中可以存在多个ENTRYPOINT指令，但是只有最后一个会生效</p><p>Dockerfile中如果既有CMD又有ENTRYPOINT，并且CMD是一个完整可执行命令，那么谁在最后谁生效</p><h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>用来在Dockerfile中定义一个触发器</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ONBUILD</span> &lt;instruction&gt;<br></code></pre></td></tr></table></figure><p>Dockerfile用来构建镜像文件，镜像文件也可以当成是基础镜像被另外一个Dockerfile用作FROM指令的参数</p><p>在后面这个Dockerfile中的FROM指令在构建过程中被执行的时候，会触发基础镜像里面的ONBUILD指令</p><p>ONBUILD不能自我嵌套，ONBUILD不会触发FROM和MAINTAINER指令</p><p>在ONBUILD指令中使用ADD和COPY要小心，因为新构建过程中的上下文在缺少指定的源文件的时候会失败</p><h1 id="将本地镜像发布到阿里云"><a href="#将本地镜像发布到阿里云" class="headerlink" title="将本地镜像发布到阿里云"></a>将本地镜像发布到阿里云</h1><p>有时候需要共享镜像或者习惯使用自己定义的镜像，可以注册私有仓库，国内推荐使用阿里云</p><p>步骤：</p><p>1.登录阿里云容器镜像服务：<a href="https://cr.console.aliyun.com/cn-hangzhou/repositories">https://cr.console.aliyun.com/cn-hangzhou/repositories</a></p><p>2.将镜像推送到阿里云</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">登录阿里云的docker仓库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker login --username=[用户名] registry.cn-hangzhou.aliyuncs.com</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建指定镜像的tag，归入某个仓库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker tag [镜像ID] registry.cn-hangzhou.aliyuncs.com/huaan/huaan:[镜像版本号]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">讲镜像推送到仓库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker push registry.cn-hangzhou.aliyuncs.com/huaan/huaan:[镜像版本号]</span><br></code></pre></td></tr></table></figure><p>3.拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull registry.cn-hangzhou.aliyuncs.com/coldest7/mytom:v1<br></code></pre></td></tr></table></figure><p>4.搜索老师的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker serch zhoupro<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ssm整合</title>
    <link href="/2022/06/28/ssm%E6%95%B4%E5%90%88/"/>
    <url>/2022/06/28/ssm%E6%95%B4%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="ssm整合"><a href="#ssm整合" class="headerlink" title="ssm整合"></a>ssm整合</h1><h2 id="1-建工程"><a href="#1-建工程" class="headerlink" title="1.建工程"></a>1.建工程</h2><h2 id="2-使用maven引入依赖"><a href="#2-使用maven引入依赖" class="headerlink" title="2.使用maven引入依赖"></a>2.使用maven引入依赖</h2><blockquote><p>spring+springmvc+mybatis+spring和mybatis整合</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.2.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- spring相关jar包 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- aop相关包 aspect相关 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjrt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 支持文件上传 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 对json格式的支持 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- mybatis相关包--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- mysql相关包 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- spring集成mybatis --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- JSP相关 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 日志 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Apache工具包 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-net<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-net<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 分页插件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.jsqlparser<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsqlparser<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-创建spring的配置文件-beans-xml"><a href="#3-创建spring的配置文件-beans-xml" class="headerlink" title="3.创建spring的配置文件 beans.xml"></a>3.创建spring的配置文件 beans.xml</h2><ol><li><p>扫描装配bean</p></li><li><p>注入数据源信息db.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://192.168.1.6:3306/demo?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span><br><span class="hljs-attr">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure></li><li><p>创建SqlSessionFactory</p></li><li><p>创建Mybatis扫描器</p></li><li><p>配置事务</p></li><li><p>事务注解生效</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/tx</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 扫描装配Bean --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.cold&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 加载配置文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:property-placeholder</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置数据源 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 创建SqlSessionFactory --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 注入数据源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 加载SqlMapConfig.xml --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:SqlMapConfig.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置分页插件 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;plugins&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 创建mybatis扫描器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.cold.mapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 定义一个事务管理器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txManage&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;txManage&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:annotation-driven</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-创建springmvc的配置文件-springmvc-xml"><a href="#4-创建springmvc的配置文件-springmvc-xml" class="headerlink" title="4.创建springmvc的配置文件 springmvc.xml"></a>4.创建springmvc的配置文件 springmvc.xml</h2><ol><li>扫描装配bean</li><li>处理映射器和适配器，对json支持</li><li>视图解析器</li><li>文件上传</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/tx</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 扫描装配Bean --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.cold&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/jsp/&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 设置哪些静态资源不要拦截 一般来说说js  css  img</span><br><span class="hljs-comment"> 以后不需要配置</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/resources/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/resources&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:resources</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 支持文件上传 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 限制文件大小 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10485760&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-创建mybatis的配置文件-SqlMapConfig-xml"><a href="#5-创建mybatis的配置文件-SqlMapConfig-xml" class="headerlink" title="5.创建mybatis的配置文件 SqlMapConfig.xml"></a>5.创建mybatis的配置文件 SqlMapConfig.xml</h2><ol><li>开启延迟加载功能</li><li>设置别名</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 延迟加载相关配置 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;aggressiveLazyLoading&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置单个的别名 --&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;typeAlias type=&quot;com.cold.entity.User&quot; alias=&quot;zls&quot;&gt;&lt;/typeAlias&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> 让mybatis批量帮助我们取别名</span><br><span class="hljs-comment"> 取别名的规则是，去两个名字，一个是大写的类名，一个是小写的类名</span><br><span class="hljs-comment"> 比如com.cold.entity.User &gt; User user</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.cold.entity&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="6-修改web-xml文件"><a href="#6-修改web-xml文件" class="headerlink" title="6.修改web.xml文件"></a>6.修改web.xml文件</h2><ol><li>监听spring程序</li><li>加载beans.xml文件</li><li>配置springmvc</li><li>编码格式处理</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 监听spring程序 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 加载beans.xml --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:beans.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 配置视图解析器 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 编码格式处理 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="7-编写java代码"><a href="#7-编写java代码" class="headerlink" title="7.编写java代码"></a>7.编写java代码</h2><ol><li><p>创建po</p></li><li><p>创建mapper</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.cold.mapper.UserMapper&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建业务层 service+serviceImpl</p></li><li><p>创建controller</p></li></ol><h2 id="8-创建jsp"><a href="#8-创建jsp" class="headerlink" title="8.创建jsp"></a>8.创建jsp</h2><p>el表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">isELIgnored=<span class="hljs-string">&quot;false</span><br></code></pre></td></tr></table></figure><p>jstl表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;%@ taglib prefix=<span class="hljs-string">&quot;c&quot;</span> uri=<span class="hljs-string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;<br></code></pre></td></tr></table></figure><p>fmt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;%@ taglib uri=<span class="hljs-string">&quot;http://java.sun.com/jsp/jstl/fmt&quot;</span> prefix=<span class="hljs-string">&quot;fmt&quot;</span> %&gt;<br></code></pre></td></tr></table></figure><p>jsp分页代码</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsp">    &lt;table&gt;<br>        &lt;tr&gt;<br>            &lt;td&gt;当前$&#123;info.pageNum&#125;页  共$&#123;info.pageSize&#125;页/$&#123;info.total&#125;条数据&lt;/td&gt;<br>            &lt;td&gt;<br>                &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;$&#123;info.pageNum&gt;1&#125;&quot;</span>&gt;<br>                    &lt;a href=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/query?pageNum=$&#123;info.pageNum-1&#125;&quot;</span>&gt;上一页&lt;/a&gt;<br>                &lt;/c:<span class="hljs-keyword">if</span>&gt;<br>                &lt;a href=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/query?pageNum=1&quot;</span>&gt;首页&lt;/a&gt;<br>                &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;$&#123;info.pageNum&lt;info.pageSize&#125;&quot;</span>&gt;<br>                    &lt;a href=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/query?pageNum=$&#123;info.pageNum+1&#125;&quot;</span>&gt;下一页&lt;/a&gt;<br>                &lt;/c:<span class="hljs-keyword">if</span>&gt;<br>                &lt;a href=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/query?pageNum=$&#123;info.pageSize&#125;&quot;</span>&gt;末页&lt;/a&gt;<br>            &lt;/td&gt;<br>        &lt;/tr&gt;<br>&lt;/table&gt;<br></code></pre></td></tr></table></figure><h2 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>springboot项目部署</title>
    <link href="/2022/06/28/springboot+vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0linux%E4%B8%8A%E9%9D%A2/"/>
    <url>/2022/06/28/springboot+vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0linux%E4%B8%8A%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><ol><li><p>vue项目打包 生成dist文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs npm">npm run build<br></code></pre></td></tr></table></figure></li><li><p>idea项目打包 生成 .jar 或者.war文件</p><p><img src="https://cdn.jsdelivr.net/gh/ltx1998/images/2022-6-21/202206211906243.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;packaging&gt;&lt;/packaging&gt; <span class="hljs-comment">//选择jar或者war  </span><br></code></pre></td></tr></table></figure><p><strong>解决打包后没有字节码文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;build&gt;<br>    &lt;plugins&gt;<br>        &lt;plugin&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br>        &lt;/plugin&gt;<br>    &lt;/plugins&gt;<br>&lt;/build&gt;<br></code></pre></td></tr></table></figure></li><li><p>使用Xshell的Xftp软件把文件复制到虚拟机中</p><p><img src="https://cdn.jsdelivr.net/gh/ltx1998/images/2022-6-21/202206211914928.png"></p></li><li><p>配置nginx.conf     把dist文件复制到nginx文件中的html</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">进入nginx文件夹中 修改配置文件</span><br>vi /usr/local/nginx/conf/nginx.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加下面的代码  解决nginx 刷新界面 404</span><br>        location / &#123;<br>            try_files $uri $uri/ /index.html;<br>&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">把dist文件复制到nginx的html文件夹中</span><br>cd /usr/local/nginx/html<br></code></pre></td></tr></table></figure></li><li><p>启动nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">进入sbin文件夹中</span><br>cd /usr/local/nginx/sbin<br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动nginx</span><br>./nginx<br><span class="hljs-meta prompt_">#</span><span class="language-bash">停止nginx</span><br>./nginx -s stop<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重启 用于修改了配置</span><br>./nginx -s reload<br></code></pre></td></tr></table></figure></li><li><p>启动springboot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar 项目名称<br></code></pre></td></tr></table></figure></li><li><p>浏览器输入ip地址</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx入门</title>
    <link href="/2022/06/28/Nginx%E5%85%A5%E9%97%A8/"/>
    <url>/2022/06/28/Nginx%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><p>Nginx 是一款高性能的 HTTP 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器。由俄罗斯的程序设计师伊戈尔·赛索耶夫所开发，官方测试 Nginx 能够支支撑 50000并发链接，并且 CPU、内存等资源消耗却非常低，运行非常稳定。</p><h2 id="二-反向代理"><a href="#二-反向代理" class="headerlink" title="二.反向代理"></a>二.反向代理</h2><p>反向代理服务器架设在服务器端，通过缓冲经常被请求的页面来缓解服务器的工作量，将客户机请求转发给内部网络上的目标服务器；并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器与目标主机一起对外表现为一个服务器。</p><h2 id="三-负载均衡"><a href="#三-负载均衡" class="headerlink" title="三.负载均衡"></a>三.负载均衡</h2><p>负载均衡，英文名称为 Load Balance，其意思就是分摊到多个操作单元上进行执行，例如 Web 服务器、FTP 服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p><h2 id="四-安装"><a href="#四-安装" class="headerlink" title="四.安装"></a>四.安装</h2><p>安装依赖和nginx:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">安装gcc,nginx的安装编译依赖于gcc环境</span><br>yum install -y gcc-c++<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装openssl,nginx的ssl模块依赖于openssl</span><br>yum install -y openssl openssl-devel<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装zlib,nginx使用gzip依赖于zlib压缩</span><br>yum install -y zlib zlib-devel<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装pcre,nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库，pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。</span><br>yum install -y pcre pcre-devel<br><span class="hljs-meta prompt_">#</span><span class="language-bash">一次性安装环境</span><br>yum install -y pcre pcre-devel openssl openssl-devel zlib zlib-devel<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装nginx</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">nginx官网下载链接nginx.org下载完成之后传到服务器,也可以通过wget工具直接下载到服务器</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装下载工具</span><br>yum install -y wget<br><span class="hljs-meta prompt_">#</span><span class="language-bash">下载</span><br>wget http://nginx.org/download/nginx-1.18.0.tar.gz<br><span class="hljs-meta prompt_">#</span><span class="language-bash">解压</span><br>tar -zxvf nginx-1.18.0.tar.gz<br><span class="hljs-meta prompt_">#</span><span class="language-bash">进入到解压目录检查文件完整性</span><br>./configure<br><span class="hljs-meta prompt_">#</span><span class="language-bash">编译和安装</span><br>make &amp;&amp; make install<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装完成之后,会在用户目录/usr/local下生成nginx文件夹,进入到nginx的sbin目录启动nginx</span><br>cd /usr/local/nginx/sbin<br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动命令</span><br>./nginx<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装nginx</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">关闭命令</span><br>./nginx -s stop<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重新加载</span><br>./nginx -s reload<br><span class="hljs-meta prompt_">#</span><span class="language-bash">开放80端口</span><br>firewall-cmd --permanent --add-port=80/tcp<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重启防火墙</span><br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><h2 id="五-配置文件结构"><a href="#五-配置文件结构" class="headerlink" title="五.配置文件结构"></a>五.配置文件结构</h2><h3 id="1-main全局配置"><a href="#1-main全局配置" class="headerlink" title="1.main全局配置"></a>1.main全局配置</h3><p>配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</p><h3 id="2-events模块"><a href="#2-events模块" class="headerlink" title="2.events模块"></a>2.events模块</h3><p>配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</p><h3 id="3-http模块"><a href="#3-http模块" class="headerlink" title="3.http模块"></a>3.http模块</h3><p>可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</p><p>nginx配置文件:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">root</span>   html;<br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>        &#125;<br><br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>        <span class="hljs-section">location</span> = /50x.html &#123;<br>            <span class="hljs-attribute">root</span>   html;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六-配置反向代理"><a href="#六-配置反向代理" class="headerlink" title="六.配置反向代理"></a>六.配置反向代理</h2><p>1.准备一台nginx和两台tomcat服务器</p><p>nginx 192.168.31.81</p><p>tomcat1 192.168.31.81:8080</p><p>tomcat2 192.168.31.81:8081</p><p>2.要实现通过nginx代理转发访问不同的域名访问到对应的tomcat服务器中</p><p><a href="http://www.tom1.com/">www.tom1.com</a> —&gt; 192.168.31.81:8080</p><p><a href="http://www.tom2.com/">www.tom2.com</a> —&gt; 192.168.31.81:8081</p><p>3.因为没有实际域名,要在windows主机配置DNS解析,修改C:\Windows\System32\drivers\etc目录下的host文件,添加两行</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.31.81</span> www.tom1.com<br><span class="hljs-number">192.168.31.81</span> www.tom2.com<br></code></pre></td></tr></table></figure><p>4.修改nginx配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">worker_processes  1;<br><br>events &#123;<br>    worker_connections  1024;<br>&#125;<br><br>http &#123;<br>    include       mime.types;<br>    default_type  application/octet-stream;<br><br>    sendfile        on;<br><br>    keepalive_timeout  65;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">代理第一台tomcat服务器的地址</span><br>    upstream tom1 &#123;<br>server 127.0.0.1:8080;<br>    &#125;<br>    #代理第二台tomcat服务器的地址<br>    upstream tom2 &#123;<br>server 127.0.0.1:8081;<br>    &#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置虚拟主机,访问域名www.tom1.com转发到第一台tomcat服务器</span><br>    server &#123;<br>        listen       80;<br>        server_name  www.tom1.com;<br><br>        location / &#123;<br>            proxy_pass http://tom1;<br>        &#125;<br>    &#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置虚拟主机,访问域名www.tom2.com转发到第二台tomcat服务器</span><br>    server &#123;<br>        listen       80;<br>        server_name  www.tom2.com;<br><br>        location / &#123;<br>            proxy_pass http://tom2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七-配置负载均衡"><a href="#七-配置负载均衡" class="headerlink" title="七.配置负载均衡"></a>七.配置负载均衡</h2><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1.配置"></a>1.配置</h3><p>(1).同样准备一台nginx和两台tomcat服务器</p><p>nginx 192.168.31.81</p><p>tomcat1 192.168.31.81:8080</p><p>tomcat2 192.168.31.81:8081</p><p>(2).实现当我们请求nginx服务器地址时,每次实际请求的服务器不一样,也就是请求同一地址,但最终访问到不同的tomcat服务器</p><p>(3).修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">worker_processes  1;<br><br>events &#123;<br>    worker_connections  1024;<br>&#125;<br><br>http &#123;<br>    include       mime.types;<br>    default_type  application/octet-stream;<br><br>    sendfile        on;<br><br>    keepalive_timeout  65;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">代理的服务器地址列表</span><br>    upstream tomcatList &#123;<br>server 127.0.0.1:8080;<br>server 127.0.0.1:8081;<br>    &#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置虚拟主机,访问域名www.tom1.com转发到第一台tomcat服务器</span><br>    server &#123;<br>        listen       80;<br>        server_name  192.168.31.81;<br><br>        location / &#123;<br>            proxy_pass http://tomcatList;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-分配方式"><a href="#2-分配方式" class="headerlink" title="2.分配方式"></a>2.分配方式</h3><p>(1).轮询</p><p>轮询是upstream的默认分配方式，即每个请求按照时间顺序轮流分配到不同的后端服务器，如果某个后端服务器down掉后，能自动剔除。</p><p>(2).权重</p><p>轮询的基础上加上比重控制,</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">upstream tomcatList &#123;<br>   <span class="hljs-built_in"> server </span>127.0.0.1:8080 <span class="hljs-attribute">weight</span>=1;<br>   <span class="hljs-built_in"> server </span>127.0.0.1:8081 <span class="hljs-attribute">weight</span>=2;<br>&#125;<br></code></pre></td></tr></table></figure><p>(3).ip_hash</p><p>根据用户的IP地址的哈希结果进行分配,也就是每个用户固定一个服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs -shell">upstream tomcatList &#123;<br>ip_hash;<br>    server 127.0.0.1:8080;<br>    server 127.0.0.1:8081;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux入门</title>
    <link href="/2022/06/28/Linux/"/>
    <url>/2022/06/28/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><p><strong>Linux</strong>（<a href="https://upload.wikimedia.org/wikipedia/commons/0/03/Linus-linux.ogg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/Speakerlink-new.svg/11px-Speakerlink-new.svg.png" alt="聆听"></a><strong><a href="https://zh.wikipedia.org/wiki/File:Linus-linux.ogg">i</a></strong><a href="https://zh.wikipedia.org/wiki/Help:%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99">&#x2F;ˈlɪnəks&#x2F;</a> <a href="https://zh.wikipedia.org/wiki/Wikipedia:%E7%99%BC%E9%9F%B3%E9%87%8D%E6%8B%BC"><em>LIN-əks</em></a>）是一种<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%8F%8A%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81%E8%BD%AF%E4%BB%B6">自由和开放源码</a>的<a href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F">类UNIX</a><a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1">操作系统</a>。该操作系统的<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>由<a href="https://zh.wikipedia.org/wiki/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E5%85%B9">林纳斯·托瓦兹</a>在1991年10月5日首次发布[<a href="https://zh.wikipedia.org/wiki/Linux#cite_note-5">5]</a>[<a href="https://zh.wikipedia.org/wiki/Linux#cite_note-6">6]</a>，在加上<a href="https://zh.wikipedia.org/wiki/%E4%BD%BF%E7%94%A8%E8%80%85%E7%A9%BA%E9%96%93">用户空间</a>的<a href="https://zh.wikipedia.org/wiki/%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F">应用程序</a>之后，成为Linux操作系统。Linux也是<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6">自由软件</a>和<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81%E8%BD%AF%E4%BB%B6">开放源代码软件</a>发展中最著名的例子。只要遵循<a href="https://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81">GNU 通用公共许可证</a>（GPL），任何个人和机构都可以自由地使用Linux的所有底层<a href="https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a>，也可以自由地修改和再发布。大多数Linux系统还包括像提供<a href="https://zh.wikipedia.org/wiki/GUI">GUI</a>的<a href="https://zh.wikipedia.org/wiki/X_Window">X Window</a>之类的程序。除了一部分专家之外，大多数人都是直接使用<a href="https://zh.wikipedia.org/wiki/Linux%E7%99%BC%E8%A1%8C%E7%89%88">Linux 发行版</a>，而不是自己选择每一样组件或自行设置。</p><p><strong>Linux</strong>严格来说是单指操作系统的内核，因操作系统中包含了许多<a href="https://zh.wikipedia.org/wiki/GUI">用户图形接口</a>和其他实用工具。如今Linux常用来指基于Linux的完整操作系统，内核则改以<a href="https://zh.wikipedia.org/wiki/Linux%E5%86%85%E6%A0%B8">Linux内核</a>称之。由于这些支持用户空间的系统工具和库主要由<a href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>于1983年发起的<a href="https://zh.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83">GNU计划</a>提供，<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E5%9F%BA%E9%87%91%E4%BC%9A">自由软件基金会</a>提议将其组合系统命名为<strong>GNU&#x2F;Linux</strong>[<a href="https://zh.wikipedia.org/wiki/Linux#cite_note-lsag-7">7]</a>[<a href="https://zh.wikipedia.org/wiki/Linux#cite_note-gnu_homepage-8">8]</a>，但Linux不属于<a href="https://zh.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83">GNU计划</a>，这个名称并没有得到社区的一致认同。</p><p>通常情况下，Linux被打包成供个人计算机和服务器使用的Linux发行版，一些流行的主流Linux发布版，包括<a href="https://zh.wikipedia.org/wiki/Debian">Debian</a>（及其派生版本<a href="https://zh.wikipedia.org/wiki/Ubuntu">Ubuntu</a>、<a href="https://zh.wikipedia.org/wiki/Linux_Mint">Linux Mint</a>）、<a href="https://zh.wikipedia.org/wiki/Fedora">Fedora</a>（及其相关版本<a href="https://zh.wikipedia.org/wiki/Red_Hat_Enterprise_Linux">Red Hat Enterprise Linux</a>、<a href="https://zh.wikipedia.org/wiki/CentOS">CentOS</a>）和<a href="https://zh.wikipedia.org/wiki/OpenSUSE">openSUSE</a>等。Linux发行版包含Linux内核和支撑内核的实用<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F">程序</a>和库，通常还带有大量可以满足各类需求的应用程序。个人计算机使用的Linux发行版通常包含<a href="https://zh.wikipedia.org/wiki/X_Window">X Window</a>和一个相应的桌面环境，如<a href="https://zh.wikipedia.org/wiki/GNOME">GNOME</a>或<a href="https://zh.wikipedia.org/wiki/KDE">KDE</a>。桌面Linux操作系统常用的<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">应用程序</a>，包括<a href="https://zh.wikipedia.org/wiki/Firefox">Firefox</a>网页浏览器、<a href="https://zh.wikipedia.org/wiki/LibreOffice">LibreOffice</a>办公软件、<a href="https://zh.wikipedia.org/wiki/GIMP">GIMP</a>图像处理工具等。由于Linux是自由软件，任何人都可以创建一个符合自己需求的Linux发行版。</p><p>centos</p><h2 id="二-准备环境"><a href="#二-准备环境" class="headerlink" title="二.准备环境"></a>二.准备环境</h2><p>所需环境:</p><p>Oracle VM VitualBox</p><p>CentOS7</p><p>XShell Plus</p><p>JDK8</p><p>Tomcat8</p><p>详细安装步骤见视频</p><p>百度云下载地址:</p><p>链接：<a href="https://pan.baidu.com/s/1kLKP-Vyq5cFI2eDjbvNvGQ">https://pan.baidu.com/s/1kLKP-Vyq5cFI2eDjbvNvGQ</a><br>提取码：63vk<br>复制这段内容后打开百度网盘手机App，操作更方便哦–来自百度网盘超级会员V3的分享</p><h2 id="三-常用命令"><a href="#三-常用命令" class="headerlink" title="三.常用命令"></a>三.常用命令</h2><p>常用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">清屏</span><br>clear<br><span class="hljs-meta prompt_">#</span><span class="language-bash">显示文件和目录 -l:文件的详细信息,-a:列出的文件包含隐藏文件</span><br>ls<br><span class="hljs-meta prompt_">#</span><span class="language-bash">进入到XXX目录</span><br>cd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">新建目录</span><br>mkdir<br><span class="hljs-meta prompt_">#</span><span class="language-bash">以文本形式显示文件内容</span><br>cat<br><span class="hljs-meta prompt_">#</span><span class="language-bash">复制文件</span><br>cp<br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除文件</span><br>rm<br><span class="hljs-meta prompt_">#</span><span class="language-bash">生成一个内容文件</span><br>echo<br><span class="hljs-meta prompt_">#</span><span class="language-bash">生成一个空文件</span><br>touch<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看网络信息</span><br>ip addr<br>ifconfig<br><span class="hljs-meta prompt_">#</span><span class="language-bash">测试网络连通</span><br>ping<br><span class="hljs-meta prompt_">#</span><span class="language-bash">系统信息</span><br>uname<br><span class="hljs-meta prompt_">#</span><span class="language-bash">主机名</span><br>hostname<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重启电脑</span><br>reboot<br><span class="hljs-meta prompt_">#</span><span class="language-bash">立刻关机</span><br>shutdown -h now<br><span class="hljs-meta prompt_">#</span><span class="language-bash">解压 -c:建立一个归档文件的参数指令,-z:是否需要用 gzip 压缩,-x:解开一个归档文件的参数指令,-v:压缩的过程中显示文件,-f:使用档名，在f之后要立即接档名</span><br>tar -zxvf xxx<br><span class="hljs-meta prompt_">#</span><span class="language-bash">编辑文件 vi:系统自带编辑</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">编辑模式:等待编辑命令输入</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">插入模式:编辑模式下，输入i进入插入模式，插入文本信息</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">命令模式:在编辑模式下，输入:进行命令模式</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">常用命令 :q(直接退出),:q!(强制退出),:wq(保存后退出,并可以新建文件)</span><br>vi<br></code></pre></td></tr></table></figure><p>防火墙配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看状态</span><br>systemctl status firewalld.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动</span><br>systemctl start firewalld.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重启</span><br>systemctl restart firewalld.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">停止</span><br>systemctl stop firewalld.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看规则</span><br>firewall-cmd --list-all<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查询端口是否开放</span><br>firewall-cmd --query-port=8080/tcp<br><span class="hljs-meta prompt_">#</span><span class="language-bash">开放8080端口</span><br>firewall-cmd --permanent --add-port=8080/tcp<br><span class="hljs-meta prompt_">#</span><span class="language-bash">移除端口</span><br>firewall-cmd --permanent --remove-port=8080/tcp<br></code></pre></td></tr></table></figure><h2 id="四-开发学习环境"><a href="#四-开发学习环境" class="headerlink" title="四.开发学习环境"></a>四.开发学习环境</h2><h3 id="1-安装Java"><a href="#1-安装Java" class="headerlink" title="1.安装Java"></a>1.安装Java</h3><p>传输文件到服务器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">lrzsz是一个xhsell传输文件的小工具,rz为上传文件到服务器,sz为下载文件到宿主机</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装</span><br>yum install -y lrzsz<br><span class="hljs-meta prompt_">#</span><span class="language-bash">传输jdk压缩包文件</span><br>rz<br></code></pre></td></tr></table></figure><p>解压:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf jdk-8u161-linux-x64.tar.gz<br><span class="hljs-meta prompt_">#</span><span class="language-bash">变更目录名</span><br>mv jdk1.8-161 jdk8<br></code></pre></td></tr></table></figure><p>环境变量配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后一行插入</span><br>export JAVA_HOME=/usr/local/java/jdk8<br>export CLASSPATH=.:$&#123;JAVA_HOME&#125;/jre/lib/rt.jar:$&#123;JAVA_HOME&#125;/lib/dt.jar:$&#123;JAVA_HOME&#125;/lib/tools.jar<br>export PATH=$PATH:$&#123;JAVA_HOME&#125;/bin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新配置文件 <span class="hljs-built_in">source</span>命令通常用于重新执行刚修改的初始化文档，如 .bash_profile 和 .profile 这些配置文件。</span><br>source profile<br></code></pre></td></tr></table></figure><p>验证:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -version<br></code></pre></td></tr></table></figure><h3 id="2-安装Tomcat"><a href="#2-安装Tomcat" class="headerlink" title="2.安装Tomcat"></a>2.安装Tomcat</h3><p>传输安装文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rz<br></code></pre></td></tr></table></figure><p>解压:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf apache-tomcat-8.5.59.tar.gz<br><span class="hljs-meta prompt_">#</span><span class="language-bash">变更目录名</span><br>mv apache-tomcat-8.5.59 tomcat8<br></code></pre></td></tr></table></figure><p>启动:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">tomcat安装好之后和windows的tomcat目录一致</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">进入到tomcat的bin目录启动tomcat</span><br>cd /bin<br>./startup.sh<br></code></pre></td></tr></table></figure><p>停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./shutdown.sh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/2022/06/28/Git%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/06/28/Git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h1><h2 id="1-绑定使用的用户"><a href="#1-绑定使用的用户" class="headerlink" title="1.绑定使用的用户"></a>1.绑定使用的用户</h2><p>git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name &quot;xxx&quot; #github的用户名<br>git config --global user.email &quot;xxx@.com&quot; #注册的用户邮箱<br>git config user.name #查看当前用户<br>git config --global user.name &quot;xxx&quot; #添加用户<br>git config --list --global #查看所有用户<br>git config --global --unset user.name &quot;xxx&quot; #删除用户<br>Git config --global user.name &quot;xxx&quot; #修改用户名<br></code></pre></td></tr></table></figure><h2 id="2-为Github设置SSH-key"><a href="#2-为Github设置SSH-key" class="headerlink" title="2.为Github设置SSH key"></a>2.为Github设置SSH key</h2><p>设置了之后 pull和push 不需要重复输入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">$ ssh-keygen -t rsa -C “自己的邮箱地址”<br></code></pre></td></tr></table></figure><h2 id="3-初始化仓库"><a href="#3-初始化仓库" class="headerlink" title="3.初始化仓库"></a>3.初始化仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git init<br></code></pre></td></tr></table></figure><h2 id="4-从工作区添加到暂存区"><a href="#4-从工作区添加到暂存区" class="headerlink" title="4.从工作区添加到暂存区"></a>4.从工作区添加到暂存区</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git add 文件 #添加单个 <br>git add . #添加全部<br>git status #查看状态<br></code></pre></td></tr></table></figure><h2 id="5-提交到本地仓库"><a href="#5-提交到本地仓库" class="headerlink" title="5.提交到本地仓库"></a>5.提交到本地仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git commit -m &quot;描述&quot;<br></code></pre></td></tr></table></figure><h2 id="6-提交到github"><a href="#6-提交到github" class="headerlink" title="6.提交到github"></a>6.提交到github</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git branch -M main<br>git remote add origin https://github.com/xxxxx/xxxxxx.git<br>git push -u origin main<br></code></pre></td></tr></table></figure><h2 id="7-更新项目"><a href="#7-更新项目" class="headerlink" title="7.更新项目"></a>7.更新项目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git pull #拉取项目<br>git push #推<br></code></pre></td></tr></table></figure><h2 id="8-解决SSL报错"><a href="#8-解决SSL报错" class="headerlink" title="8.解决SSL报错"></a>8.解决SSL报错</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global http.sslVerify &quot;false&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker mysql 连接2059错误解决办法</title>
    <link href="/2022/06/28/dockers%20mysql%20%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"/>
    <url>/2022/06/28/dockers%20mysql%20%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="docker-mysql-连接2059错误解决办法"><a href="#docker-mysql-连接2059错误解决办法" class="headerlink" title="docker mysql 连接2059错误解决办法"></a>docker mysql 连接2059错误解决办法</h2><ol><li><p>进入mysql容器中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it mysql /bin/bash<br></code></pre></td></tr></table></figure></li><li><p>登陆mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -uroot -p<br></code></pre></td></tr></table></figure></li><li><p>输入密码然后输入代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;填你的密码&#x27; PASSWORD EXPIRE NEVER; #修改密码<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;huangwenjie&#x27;; #修改本地密码<br></code></pre></td></tr></table></figure></li><li><p>退出mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit; <br></code></pre></td></tr></table></figure></li><li><p>退出容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GitHub+PicGo+jsdelivr 搭建图床步骤</title>
    <link href="/2022/06/28/GitHub+PicGo+jsdelivr%20%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/06/28/GitHub+PicGo+jsdelivr%20%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<p><strong>准备工作:</strong></p><ol><li>使用GitHub创建一个公开的仓库，然后点击头像，<code>settings</code>里面找到<code>Developer settings</code>，然后在</li></ol><p>左侧菜单栏找到<code>Personal access tokens</code>，选择<code>new token</code>,名字和<code>repo</code>打勾就行，其他随便弄弄，把token保存下来，GitHub的任务就完成了.</p><p>GitHub的传送门：<a href="https://github.com/">GitHub</a></p><p>PicGo的传送门：<a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0">picgo</a></p><ol start="2"><li>这里选择最新稳定版本的，加了beta都是测试版本，下载好了打开软件</li></ol><img src="https://cdn.jsdelivr.net/gh/ltx1998/images/2022-6-13/202206131927421.png"/><p>左侧选择GitHub，其他设置分别是：</p><blockquote><ul><li>用户名+仓库名</li><li>分支名</li><li>刚刚复制好的token</li><li>存储到GitHub的路径，建议在前面加上日期，方便管理</li><li>域名：<a href="https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D%E4%BB%93%E5%BA%93%E5%90%8D">https://cdn.jsdelivr.net/gh/用户名仓库名</a></li></ul></blockquote><p>3.使用说明</p><p>一般直接把照片拖进去，或者用快捷键<code>PicGo设置</code>,修改快捷键，设置成Alt+c，方便好用</p><img src="https://cdn.jsdelivr.net/gh/ltx1998/images/2022-6-13/202206131927161.png"/>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
